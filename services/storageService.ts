
import { Note, AppSettings } from '../types';

// Clé pour stocker les paramètres de l'application
const SETTINGS_KEY = 'devmemory_settings';
const NOTES_KEY = 'devmemory_notes';

// Valeurs par défaut
export const DEFAULT_SETTINGS: AppSettings = {
  storageMode: 'LOCAL',
  apiUrl: 'http://localhost:8080/api/notes'
};

export const getSettings = (): AppSettings => {
  const saved = localStorage.getItem(SETTINGS_KEY);
  return saved ? JSON.parse(saved) : DEFAULT_SETTINGS;
};

export const saveSettings = (settings: AppSettings) => {
  localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
};

// Interface générique pour le CRUD
interface StorageProvider {
  getAll(): Promise<Note[]>;
  save(note: Note): Promise<Note>;
  delete(id: string): Promise<void>;
}

// Implémentation LocalStorage
const LocalProvider: StorageProvider = {
  async getAll() {
    const saved = localStorage.getItem(NOTES_KEY);
    return saved ? JSON.parse(saved) : [];
  },
  async save(note: Note) {
    const notes = await this.getAll();
    const index = notes.findIndex(n => n.id === note.id);
    let newNotes;
    if (index >= 0) {
      newNotes = notes.map(n => n.id === note.id ? note : n);
    } else {
      newNotes = [note, ...notes];
    }
    localStorage.setItem(NOTES_KEY, JSON.stringify(newNotes));
    return note;
  },
  async delete(id: string) {
    const notes = await this.getAll();
    const newNotes = notes.filter(n => n.id !== id);
    localStorage.setItem(NOTES_KEY, JSON.stringify(newNotes));
  }
};

// Implémentation API (Spring Boot)
const ApiProvider = (url: string): StorageProvider => ({
  async getAll() {
    try {
      const res = await fetch(url);
      if (!res.ok) throw new Error('Failed to fetch');
      return await res.json();
    } catch (e) {
      console.error("API Error", e);
      throw e;
    }
  },
  async save(note: Note) {
    // Check if update or create based on if ID exists in backend logic, 
    // but usually frontend sends POST for new and PUT for update.
    // For simplicity here, we assume the UI handles the distinction or use PUT for upsert if supported.
    // Let's try to detect based on fetching. Ideally the UI tells us.
    // We will use a simple heuristic: We will use POST for everything and let backend handle upsert OR
    // we assume the UI calls save.
    
    // Actually, distinct PUT/POST is cleaner.
    // We will assume 'save' does an upsert logic on the frontend, but here we need to be careful.
    // Let's simplify: try PUT, if 404, try POST? No, too slow.
    // Let's assume the backend 'save' method handles upsert on ID presence, 
    // OR we change the provider interface.
    // Given the simple requirement, let's use POST for create and PUT for update logic inside the App.tsx,
    // but here we merge them.
    
    // Simplification: We will use POST for everything if the backend supports upsert via save(),
    // otherwise Spring Data REST usually separates them.
    // Let's use the ID to decide.
    
    // Since this is a generic 'save', we'll implement a helper in App.tsx to call specific methods,
    // or improve this Provider to handle it.
    
    // Let's refine: The backend usually expects POST for creation (no ID or ignored ID) and PUT for update.
    // Since our Note object ALWAYS has an ID generated by frontend in the current logic,
    // we need to check if it exists? 
    // Better approach: Just use POST for now, and ensure your Spring Controller uses repository.save() which does upsert if ID exists.
    
    const method = 'POST'; 
    const res = await fetch(url, {
      method,
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(note)
    });
    return await res.json();
  },
  async delete(id: string) {
    await fetch(`${url}/${id}`, { method: 'DELETE' });
  }
});

// Helper pour gérer le PUT vs POST plus proprement
export const apiService = {
    getAll: async (apiUrl: string) => {
        const res = await fetch(apiUrl);
        if(!res.ok) throw new Error("Erreur connexion API");
        return await res.json();
    },
    create: async (apiUrl: string, note: Note) => {
        const res = await fetch(apiUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(note)
        });
        return await res.json();
    },
    update: async (apiUrl: string, note: Note) => {
        const res = await fetch(`${apiUrl}/${note.id}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(note)
        });
        return await res.json();
    },
    delete: async (apiUrl: string, id: string) => {
        await fetch(`${apiUrl}/${id}`, { method: 'DELETE' });
    }
}

export const storage = {
    local: LocalProvider
};
